import queue        # Thread-safe FIFO buffer (to pass audio from callback ‚Üí API requests)
import sys          # For printing warnings/errors to stderr
import signal       # To handle Ctrl+C gracefully on Windows
import time         # (Not used here, could be removed safely)

import numpy as np  # For converting audio floats ‚Üí int16 PCM
import sounddevice as sd  # Library for capturing microphone audio
from google.cloud import speech  # Google Speech-to-Text client library

# ====== Config ======
LANGUAGE = "en-US"          # Language to recognize (use BCP-47 codes like 'fr-FR' for French)
SAMPLE_RATE = 16000         # Google STT expects 16 kHz for typical voice recordings
BLOCKS_PER_SECOND = 10      # How often we capture a block of audio (10 ‚Üí ~100ms per chunk)
CHANNELS = 1                # Mono audio (1 mic channel), STT usually needs mono

# ====== Audio capture -> queue ======
audio_q = queue.Queue()     # Queue decouples fast audio capture from slower network requests

def audio_callback(indata, frames, time_info, status):
    """This function is called automatically by sounddevice for each audio block."""
    if status:
        print(f"[Audio warning] {status}", file=sys.stderr, flush=True)
    # Convert float32 audio samples (range -1..1) into int16 PCM (required by LINEAR16 encoding)
    audio_q.put((indata.copy() * 32767).astype(np.int16).tobytes())

def request_generator():
    """Generator that yields audio chunks wrapped in StreamingRecognizeRequest for Google STT."""
    while True:
        chunk = audio_q.get()       # Get audio from the queue
        if chunk is None:           # If None pushed ‚Üí stop the generator
            return
        yield speech.StreamingRecognizeRequest(audio_content=chunk)

def main():
    client = speech.SpeechClient()  # Initialize the Google Speech-to-Text client

    # ====== Recognition configuration ======
    config = speech.RecognitionConfig(
        encoding=speech.RecognitionConfig.AudioEncoding.LINEAR16, # PCM 16-bit encoding
        sample_rate_hertz=SAMPLE_RATE,  # Must match microphone capture rate
        language_code=LANGUAGE,         # Language to recognize
        enable_automatic_punctuation=True, # Add punctuation automatically
        model="latest_long",               # Model optimized for long-form dictation (can omit)
    )
    streaming_config = speech.StreamingRecognitionConfig(
        config=config,
        interim_results=True,    # Get partial results in real time
        single_utterance=False,  # Keep listening until stopped (not just one phrase)
    )

    # ====== Open microphone stream ======
    blocksize = int(SAMPLE_RATE / BLOCKS_PER_SECOND)  # e.g., 16000/10 = 1600 samples per block (~100ms)
    print("üéôÔ∏è  Listening... press Ctrl+C to stop.\n")

    with sd.InputStream(
        samplerate=SAMPLE_RATE,     # Mic sample rate
        channels=CHANNELS,          # Mono
        dtype="float32",            # Sounddevice provides float32 in range -1..1
        blocksize=blocksize,        # How many frames per callback
        callback=audio_callback,    # Function that handles each block
    ):
        # Start streaming RPC to Google Speech API
        requests = request_generator()
        responses = client.streaming_recognize(streaming_config, requests)

        try:
            # Process responses in real-time
            for resp in responses:
                for result in resp.results:
                    alt = result.alternatives[0]
                    if result.is_final:
                        # Final transcript (Google decided the phrase is complete)
                        print(f"FINAL: {alt.transcript}")
                    else:
                        # Interim (partial) result ‚Üí overwrite line for live feel
                        print(f"\rpartial: {alt.transcript}...", end="", flush=True)
        except KeyboardInterrupt:
            pass
        finally:
            # Send None to stop the generator gracefully
            audio_q.put(None)
            print("\nüõë Stopped.")

if __name__ == "__main__":
    # On Windows, make Ctrl+C work properly with sounddevice + streaming
    signal.signal(signal.SIGINT, signal.default_int_handler)
    try:
        main()
    except KeyboardInterrupt:
        print("\nüõë Exiting.")
